// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ShowResult
#pragma kernel AttributeClusters
#pragma kernel UpdateClusterCenters
#pragma kernel RandomSwap
#pragma kernel ValidateCandidates

#define num_clusters 6
#define threshold 0.1

bool final;
bool rejectOld;
bool showReference;

uint randomClusterCenter;

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> tex_input;
RWTexture2D<float4> tex_output;

Texture2DArray<float4> tex_arr_clusters_r;
RWTexture2DArray<float4> tex_arr_clusters_rw;

SamplerState sampler_tex_arr_clusters_r;

RWStructuredBuffer<float3> cbuf_cluster_centers;
RWStructuredBuffer<uint2> cbuf_random_positions;

inline float pow2(float x){
	return x*x;
}

inline float pow3(float x){
	return x*x*x;
}

inline float pow4(float x){
	return pow2(
		pow2(x)
	);
}

inline float pow5(float x){
	return pow4(x)*x;
}

float2 project(float3 col)
{
	col -= min(
		col.r,
		min(
			col.g,
			col.b
		)
	);
	col /= dot(1, col);
	return col.rg;
}

float test(float3 col) {
	float3 sf = col - min(
		col.r,
		min(
			col.g,
			col.b
		)
	);

	return dot(sf, 1);
}

float3 RGBtoHSV(float3 RGB)
{
    float3 HSV = 0;
    float M = min(RGB.r, min(RGB.g, RGB.b));
    HSV.z = max(RGB.r, max(RGB.g, RGB.b));
    float C = HSV.z - M;
    if (C != 0)
    {
        HSV.y = C / HSV.z;
        float3 D = (((HSV.z - RGB) / 6) + (C / 2)) / C;
        if (RGB.r == HSV.z)
            HSV.x = D.b - D.g;
        else if (RGB.g == HSV.z)
            HSV.x = (1.0/3.0) + D.r - D.b;
        else if (RGB.b == HSV.z)
            HSV.x = (2.0/3.0) + D.g - D.r;
        if ( HSV.x < 0.0 ) { HSV.x += 1.0; }
        if ( HSV.x > 1.0 ) { HSV.x -= 1.0; }
    }
    return HSV;
}

float3 HUEtoRGB(in float H)
{
	float R = abs(H * 6 - 3) - 1;
	float G = 2 - abs(H * 6 - 2);
	float B = 2 - abs(H * 6 - 4);
	return saturate(float3(R,G,B));
}

float3 HSVtoRGB(in float3 HSV)
{
	float3 RGB = HUEtoRGB(HSV.x);
	return ((RGB - 1) * HSV.y + 1) * HSV.z;
}

[numthreads(32,32,1)]
void ShowResult (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

	float4 color = float4(0,0,0,1);
	for (int i = 0; i < num_clusters; i++){
		if (
			tex_arr_clusters_r[uint3(id.xy, i)].a == 1 //&& i == 0
		) {
			color.rg = cbuf_cluster_centers[i].rg;
			color.b = 1.0 - color.r - color.g;
		}
	}

	if (showReference) {
		color.rg = project(tex_input[id.xy].rgb);
		uint borderWidth = 8;
	}

	if (test(tex_input[id.xy].rgb) <= threshold){
		color.rgb /= 128.0;
	}

	uint borderWidth = 8;

	if (showReference) {
		if (
			id.x < borderWidth ||
			id.x > 256 - borderWidth ||
			id.y < borderWidth ||
			id.y > 256 - borderWidth
		) {
			color.rgb = float3(1,0,0);
		}
	}

	tex_output[id.xy] = color;
}

[numthreads(32,32,1)]
void AttributeInitialClusters (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

	float3 col = tex_input[id.xy].rgb;
	int clusterID = (id.x + id.y * 256) % num_clusters;
	bool included = test(col) > threshold;

	for (int k = 0; k < num_clusters; k++){
		float4 result = 0;

		if (included) {
			//result.z = dist*dist;

			if (k == clusterID) {
				result.xy = project(col);
				result.w = 1;
			}
		}

		tex_arr_clusters_rw[uint3(id.xy, k)] = result;
	}
}

[numthreads(32,32,1)]
void AttributeClusters (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

	float min_dist = 100;
	// difference calculated on 2 coordinates within [0,1] range
	// theoretical maximum distance is sqrt(2)
	
	uint clusterID;

	float3 col = tex_input[id.xy].rgb;
	bool included = test(col) > threshold;

	float dist_list[num_clusters];

	for (int i = 0; i < num_clusters; i++) {
		float dist = length(
			cbuf_cluster_centers[i].rg -
			project(col)
		);

		dist_list[i] = dist;

		if (dist < min_dist) {
			clusterID = i;
			min_dist = dist;
		}
	}

	float MSE = pow2(min_dist);

	for (uint k = 0; k < num_clusters; k++) {
		float top = min_dist * pow5(
			min_dist / dist_list[k]
		);

		float bottom = 1.0;

		for (uint n = 0; n < num_clusters; n++){
			if (n == clusterID) {
				continue;
			}

			bottom += pow3(min_dist / dist_list[n]);
		}

		float w = top / pow2(bottom);

		// simple K-Means
		// w = (k == clusterID);

		float4 result = float4(
			project(col) * w,
			MSE,
			w
		);

		if (final) {
			result.z = (k == clusterID);
		}

		if (!included && !final) {
			result.xyw = 0;
		}

		tex_arr_clusters_rw[uint3(id.xy, k)] = result;
	}
}

[numthreads(1,1,1)]
void RandomSwap (uint3 id : SV_DispatchThreadID)
{
	cbuf_cluster_centers[randomClusterCenter].xy = project(
		tex_input[
			cbuf_random_positions[randomClusterCenter]
		].rgb
	);
}


[numthreads(32,1,1)]
void ValidateCandidates (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= num_clusters) {
		return;
	}

	float3 old = cbuf_cluster_centers[id.x + num_clusters];
	float3 candidate = cbuf_cluster_centers[id.x];

	// z is same on all cluster centers
	// and contains MSE across ALL clusters

	if (candidate.z < old.z) {
		cbuf_cluster_centers[id.x + num_clusters] = cbuf_cluster_centers[id.x];
	} else {
		cbuf_cluster_centers[id.x] = cbuf_cluster_centers[id.x + num_clusters];
	}
}

// how to store the previous overall MSE to compare to candidate overall MSE?
// store it in cluster center compute buffer (a copy in every entry)

[numthreads(32,1,1)]
void UpdateClusterCenters (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= num_clusters) {
		return;
	}

    float4 aggregatedColor = tex_arr_clusters_r.SampleLevel(
		sampler_tex_arr_clusters_r,
		float3(
			0.5, 0.5, id.x
		),
		8
	);

	// z is the same on all cluster centers
	// and contains MSE across ALL clusters

	float3 clusterCenter;
	clusterCenter.z = aggregatedColor.z;

	if (aggregatedColor.a != 0) {
		clusterCenter.xy = aggregatedColor.xy / aggregatedColor.w;
	} else {
		if (true) {
			float3 col = tex_input[
				cbuf_random_positions[id.x]
			].rgb;
			clusterCenter.xy = project(col);
			clusterCenter.z = 1.#INF;
		} else {
			clusterCenter.xy = cbuf_cluster_centers[id.x].xy;
			clusterCenter.z = 1.#INF;
		}
	}

	cbuf_cluster_centers[id.x] = clusterCenter;
	if (rejectOld) {
		cbuf_cluster_centers[id.x + num_clusters] = clusterCenter;
	}

	//	0	1024
	//	1	512
	//	2	256
	//	3	128
	//	4	64
	//	5	32
	//	6	16
	//	7	8
	//	8	4
	//	9	2
	//	10	1
}