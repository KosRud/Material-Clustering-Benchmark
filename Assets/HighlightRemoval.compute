// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ShowResult
#pragma kernel AttributeClusters
#pragma kernel UpdateClusterCenters
#pragma kernel AttributeInitialClusters
#pragma kernel RandomSwap
#pragma kernel ValidateCandidates

#define numClusters 6
#define threshold 0.1

bool final;
bool validateCandidate;

uint randomClusterCenter;

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> tex_input;
RWTexture2D<float4> tex_output;

Texture2DArray<float4> tex_arr_clusters_r;
RWTexture2DArray<float4> tex_arr_clusters_rw;

SamplerState sampler_tex_arr_clusters_r;

RWStructuredBuffer<float3> cbuf_cluster_centers;
RWStructuredBuffer<uint2> cbuf_random_positions;

float2 project(float3 col)
{
	col -= min(
		col.r,
		min(
			col.g,
			col.b
		)
	);
	col /= dot(1, col);
	return col.rg;
}

float test(float3 col) {
	float3 sf = col - min(
		col.r,
		min(
			col.g,
			col.b
		)
	);

	return dot(sf, 1);
}

float3 RGBtoHSV(float3 RGB)
{
    float3 HSV = 0;
    float M = min(RGB.r, min(RGB.g, RGB.b));
    HSV.z = max(RGB.r, max(RGB.g, RGB.b));
    float C = HSV.z - M;
    if (C != 0)
    {
        HSV.y = C / HSV.z;
        float3 D = (((HSV.z - RGB) / 6) + (C / 2)) / C;
        if (RGB.r == HSV.z)
            HSV.x = D.b - D.g;
        else if (RGB.g == HSV.z)
            HSV.x = (1.0/3.0) + D.r - D.b;
        else if (RGB.b == HSV.z)
            HSV.x = (2.0/3.0) + D.g - D.r;
        if ( HSV.x < 0.0 ) { HSV.x += 1.0; }
        if ( HSV.x > 1.0 ) { HSV.x -= 1.0; }
    }
    return HSV;
}

float3 HUEtoRGB(in float H)
{
	float R = abs(H * 6 - 3) - 1;
	float G = 2 - abs(H * 6 - 2);
	float B = 2 - abs(H * 6 - 4);
	return saturate(float3(R,G,B));
}

float3 HSVtoRGB(in float3 HSV)
{
	float3 RGB = HUEtoRGB(HSV.x);
	return ((RGB - 1) * HSV.y + 1) * HSV.z;
}

[numthreads(32,32,1)]
void ShowResult (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

	float4 color = float4(0,0,0,1);
	for (int i = 0; i < numClusters; i++){
		if (
			tex_arr_clusters_r[uint3(id.xy, i)].a == 1 //&& i == 0
		) {
			color.rg = cbuf_cluster_centers[i].rg;
			color.b = 1.0 - color.r - color.g;

			if (test(tex_input[id.xy].rgb) <= threshold){
				color.rgb *= 0.0625;
			}

			//color.rgb = (i + 1.0) / numClusters;
		}
	}

	//float2 coord = id.xy / 1024.0;
	//
	//color.g = dot(coord.xy, 1) - 1.0;
	//color.r = coord.x - color.g;
	//color.b = coord.y - color.g;
	//
	//if (color.g < 0) {
	//	color = 0;
	//}

	tex_output[id.xy] = color;
}

[numthreads(32,32,1)]
void AttributeInitialClusters (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

	float3 col = tex_input[id.xy].rgb;
	int clusterID = (id.x + id.y * 1024) % numClusters;
	bool included = test(col) > threshold;

	for (int k = 0; k < numClusters; k++){
		float4 result = 0;

		if (included) {
			//result.z = dist*dist;

			if (k == clusterID) {
				result.xy = project(col);
				result.w = 1;
			}
		}

		tex_arr_clusters_rw[uint3(id.xy, k)] = result;
	}
}

[numthreads(32,32,1)]
void AttributeClusters (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

	float minDist = 100000000.0;
	int clusterID = 0;

	float3 col = tex_input[id.xy].rgb;
	bool included = test(col) > threshold;

	for (int i = 0; i < numClusters; i++) {
		float dist = length(
			cbuf_cluster_centers[i].rg -
			project(col)
		);

		if (dist < minDist) {
			clusterID = i;
			minDist = dist;
		}
	}

	float4 result = 0;

	if (included) {
		result.z = minDist*minDist;
	}

	for (int k = 0; k < numClusters; k++){		
		if (
			k == clusterID && 
			(included || final)
		) {
			result.xy = project(col);
			result.w = 1;
		} else {
			result.xyw = 0;
		}

		tex_arr_clusters_rw[uint3(id.xy, k)] = result;
	}
}

[numthreads(1,1,1)]
void RandomSwap (uint3 id : SV_DispatchThreadID)
{
	cbuf_cluster_centers[randomClusterCenter].xy = project(
		tex_input[
			cbuf_random_positions[randomClusterCenter]
		].rgb
	);
}


[numthreads(32,1,1)]
void ValidateCandidates (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numClusters) {
		return;
	}

	float3 old = cbuf_cluster_centers[id.x + numClusters];
	float3 candidate = cbuf_cluster_centers[id.x];

	// z is same on all cluster centers
	// and contains MSE across ALL clusters

	if (candidate.z < old.z) {
		cbuf_cluster_centers[id.x + numClusters] = cbuf_cluster_centers[id.x];
	} else {
		cbuf_cluster_centers[id.x] = cbuf_cluster_centers[id.x + numClusters];
	}
}

// how to store the previous overall MSE to compare to candidate overall MSE?
// store it in cluster center compute buffer (a copy in every entry)

[numthreads(32,1,1)]
void UpdateClusterCenters (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numClusters) {
		return;
	}

    float4 aggregatedColor = tex_arr_clusters_r.SampleLevel(
		sampler_tex_arr_clusters_r,
		float3(
			0.5, 0.5, id.x
		),
		10
	);

	// z is the same on all cluster centers
	// and contains MSE across ALL clusters

	float3 clusterCenter;

	if (aggregatedColor.a != 0) {
		clusterCenter.xy = aggregatedColor.xy / aggregatedColor.w;
	} else {
		float3 col = tex_input[
			cbuf_random_positions[id.x]
		].rgb;

		clusterCenter.xy = project(col);
	}

	clusterCenter.z = aggregatedColor.z;

	cbuf_cluster_centers[id.x] = clusterCenter;

	//	0	1024
	//	1	512
	//	2	256
	//	3	128
	//	4	64
	//	5	32
	//	6	16
	//	7	8
	//	8	4
	//	9	2
	//	10	1
}