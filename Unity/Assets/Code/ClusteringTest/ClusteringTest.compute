// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ShowResult
#pragma kernel AttributeClusters
#pragma kernel UpdateClusterCenters
#pragma kernel RandomSwap
#pragma kernel ValidateCandidates
#pragma kernel SubSample

#define threshold 0.05
#define max_num_clusters 32

bool reject_old;
bool store_variance;
bool do_random_sample_empty_clusters;
bool KHM;

uint randomClusterCenter;
uint subsample_mip_level;
uint mip_level;
uint texture_size;

uint num_clusters;

uint sub_sample_multiplier;
uint2 sub_sample_offset;
bool downscale;

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> tex_input;
SamplerState sampler_tex_input;

RWTexture2D<float4> tex_output;

RWTexture2DArray<float4> tex_arr_clusters_rw;
Texture2DArray<float4> tex_arr_clusters_r;
SamplerState sampler_tex_arr_clusters_r;

RWTexture2D<float2> tex_variance_rw;
Texture2D<float2> tex_variance_r;
SamplerState sampler_tex_variance_r;

RWStructuredBuffer<float4> cbuf_cluster_centers;
RWStructuredBuffer<int4> cbuf_random_positions;

static const float3x3 kkk2rgb_matrix = {
	1,	1, -0.6667,
	1,	0,	1.3333,
	1,	-1,	-0.6667
};

static const float3x3 rgb2kkk_matrix = {
	0.3333,	0.3333,	0.3333,
	0.5,	0,		-0.5,
	-0.25,	0.5,	-0.25
};

inline float isNearZero(float x){
	// 32 bit float = 6 digits precision
	return abs(x) < 0.000001;
}

float2 project(float3 col)
{
	/* 
		specular-free
		i.e., maximize saturation
	*/
	col -= min(
		col.r,
		min(
			col.g,
			col.b
		)
	);

    // normalize
    col /= (dot(col, 1) + 0.00001);

	// transform to kkk color space
	col = mul(rgb2kkk_matrix,col);

	// return chromaticity axes, ignore intensity
	return col.gb;
}

float test(float3 col) {

	// specular-free
	col -= min(
		col.r,
		min(
			col.g,
			col.b
		)
	);

	return dot(col, 1);
}

[numthreads(8,8,1)]
void ShowResult (uint3 id : SV_DispatchThreadID)
{
	float4 color = float4(0,0,0,1);
	for (uint i = 0; i < num_clusters; i++){
		if (
			tex_arr_clusters_r[uint3(id.xy, i)].a == 1
		) {
			color.rg = cbuf_cluster_centers[i].rg;
			
			/*
				convert from kkk chromaticity to RGB
				assume maximum intensity
			*/
			color.rgb = mul(
				kkk2rgb_matrix,
				float3(0.3333, color.rg)
			);
		}
	}

	if (test(tex_input[id.xy].rgb) <= threshold){
		color.rgb /= 32.0;
	}

	tex_output[id.xy] = color;
}

[numthreads(8,8,1)]
void SubSample (uint3 id : SV_DispatchThreadID)
{
    if (downscale == false){
        tex_output[id.xy] = tex_input[
            id.xy * sub_sample_multiplier + sub_sample_offset
        ];
    } else {
        tex_output[id.xy] = tex_input.SampleLevel(
            sampler_tex_input,
            float2(
                (id.xy + 0.5) / texture_size
            ),
            subsample_mip_level
        );
    }
}

[numthreads(8,8,1)]
void AttributeClusters (uint3 id : SV_DispatchThreadID)
{
	float min_dist = 1000;
	// 2 coordinates within [-0.5; 0.5] range
	// theoretical maximum distance is sqrt(2)
	
	uint clusterID = -1;

	float3 col = tex_input[id.xy].rgb;
    float2 projCol = project(col);

	bool included = test(col) > threshold;

	float dist_list[max_num_clusters];

	for (uint i = 0; i < num_clusters; i++) {
		float dist = length(
			cbuf_cluster_centers[i].rg -
			projCol
		);

		dist_list[i] = dist;

		if (dist < min_dist) {
			clusterID = i;
			min_dist = dist;
		}
	}

	for (uint k = 0; k < num_clusters; k++) {
		float4 result = 0;

		if (!KHM){
			// K-Means weights
			result.w = (k == clusterID);
		} else {
			/*
				K-Harmonic means weights

				q_{i,k}
				(Equation 7.6)

				Zhang, Bin. "Generalized k-harmonic means--boosting in unsupervised learning." HP LABORATORIES TECHNICAL REPORT HPL 137 (2000).
			*/

            if (isNearZero(min_dist)) {
				// prevent division by zero
                result.w = (k == clusterID);
            } else {
				// abs suppresses compiler warning
				// it is free in terms of performance
				// it is passed as a flag to an existing operation
				// instead of creating a new operation

				float top = pow(abs(min_dist), 1.5);
           		float bottom = 1.0;


                if (k != clusterID) {
                    top *= pow(abs(min_dist / dist_list[k]), 5.5);
                }

                for (uint n = 0; n < num_clusters; n++){
                    if (n == clusterID) {
                        continue;
                    }
                    
                    bottom += pow(abs(min_dist / dist_list[n]), 3.5);
                }

				result.w = top / (bottom * bottom);
            }
        }

		if (!included) {
			result.w = 0;
		}
		result.xy = projCol * result.w;

		switch(k) {
			case 0:
				result.z = included ? (min_dist * min_dist) : 0;
				break;
			case 1:
				result.z = included;
				break;
			default:
				result.z = 0;
				break;
		}

		tex_arr_clusters_rw[uint3(id.xy, k)] = result;
	}
}

[numthreads(1,1,1)]
void RandomSwap (uint3 id : SV_DispatchThreadID)
{
    float3 sampleCol = tex_input[
        cbuf_random_positions[randomClusterCenter].xy
    ].rgb;

    if (
        // prevents actual bugs!
        test(sampleCol) <= threshold
    ) {
        return;
    }

	cbuf_cluster_centers[randomClusterCenter].xy = project(sampleCol);
}

[numthreads(32,1,1)]
void ValidateCandidates (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= num_clusters) {
		return;
	}

	float4 old = cbuf_cluster_centers[id.x + num_clusters];
	float4 candidate = cbuf_cluster_centers[id.x];

	// z is same on all cluster centers
	// and contains Variance across ALL clusters

	if (candidate.z < old.z) {
		cbuf_cluster_centers[id.x + num_clusters] = candidate;
	} else {
		cbuf_cluster_centers[id.x] = old;
	}
}

// how to store the previous overall Variance to compare to candidate overall Variance?
// store it in cluster center compute buffer (a copy in every entry)

[numthreads(32,1,1)]
void UpdateClusterCenters (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= num_clusters) {
		return;
	}

	float4 aggregatedColor = tex_arr_clusters_r.SampleLevel(
		sampler_tex_arr_clusters_r,
		float3(0.5, 0.5, id.x),
		mip_level
	);

	float4 clusterCenter = 0;

	if (id.x == 0){
		// compute variance

		float aggregatedVariance = 
		// included ? (min_dist * min_dist) : 0
		tex_arr_clusters_r.SampleLevel(
			sampler_tex_arr_clusters_r,
			float3(0.5, 0.5, 0),
			mip_level
		).z;

		float aggregatedIncluded = 
		// included
		tex_arr_clusters_r.SampleLevel(
			sampler_tex_arr_clusters_r,
			float3(0.5, 0.5, 1),
			mip_level
		).z

		// clusterCenter.z = variance
		if (!isNearZero(aggregatedIncluded)){
			clusterCenter.z = aggregatedVariance / aggregatedIncluded;
		} else {
			clusterCenter.z = -1;
		}
	}

	// clusterCenter.w = not empty (flag)
	clusterCenter.w = 1;

	// clusterCenter.xy = cluster center
	if (!isNearZero(aggregatedColor.w)) {
		// cluster is not empty

		clusterCenter.xy = aggregatedColor.xy / aggregatedColor.w;
	} else {
		// cluster is empty

		// cluser is empty (flag)
		clusterCenter.w = 0;

		if (do_random_sample_empty_clusters) {
			// randomize empty cluster
			clusterCenter.xy = project(
				tex_input[
					cbuf_random_positions[id.x].xy
				].rgb
			);
		} else {
			// keep previous cluster center
			clusterCenter.xy = cbuf_cluster_centers[id.x].xy;
		}
	}

	cbuf_cluster_centers[id.x] = clusterCenter;

	if (reject_old) {
		cbuf_cluster_centers[id.x + num_clusters] = clusterCenter;
	}
}