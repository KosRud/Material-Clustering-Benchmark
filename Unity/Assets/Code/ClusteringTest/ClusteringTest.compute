// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ShowResult
#pragma kernel AttributeClusters
#pragma kernel UpdateClusterCenters
#pragma kernel RandomSwap
#pragma kernel ValidateCandidates
#pragma kernel SubSample

#define valid_threshold 0.05
#define max_num_clusters 32

bool reject_old;
bool store_variance;
bool do_random_sample_empty_clusters;
bool KHM;
float p;	// KHM parameter

uint random_cluster_center;
uint subsample_mip_level;
uint mip_level;
uint texture_size;

uint num_clusters;

uint sub_sample_multiplier;
uint2 sub_sample_offset;
bool downscale;

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> tex_input;
SamplerState sampler_tex_input;

RWTexture2D<float4> tex_output;

RWTexture2DArray<float4> tex_arr_clusters_rw;
Texture2DArray<float4> tex_arr_clusters_r;
SamplerState sampler_tex_arr_clusters_r;

RWTexture2D<float2> tex_variance_rw;
Texture2D<float2> tex_variance_r;
SamplerState sampler_tex_variance_r;

RWStructuredBuffer<float4> cbuf_cluster_centers;
RWStructuredBuffer<int4> cbuf_random_positions;

bool is_variance_valid(float x){
	/*
		positive number 	|	valid variance
		-1 					|	not a single pixel has sufficient chromatic component
	*/
	return x > -0.5;
}

static const float3x3 iii_2_rgb_matrix = {
	1,	1, -0.6667,
	1,	0,	1.3333,
	1,	-1,	-0.6667
};

static const float3x3 rgb_2_iii_matrix = {
	0.3333,	0.3333,	0.3333,
	0.5,	0,		-0.5,
	-0.25,	0.5,	-0.25
};

inline float is_near_zero(float x){
	// 32 bit float = 6 digits precision
	return abs(x) < 0.00001;
}

/*
	color representation used for material clustering

	maximize HSI intensity and saturation =>
		hue is unaffected by diffuse and specular shading
	
	can't cluster by hue directly with K-Means, because it is circular
	instead, use I2,I3 plane from I1,I2,I3 color space
	I2,I3 plane corresponds to HSI chromaticity (hue / saturation)
*/
float2 project(float3 col)
{
	/* 
		maximize HSI saturation
		intensity becomes invalid
	*/
	col -= min(
		col.r,
		min(
			col.g,
			col.b
		)
	);

    /*
		normalize intensity
		
		this creates potential division by zero
		erroneous pixels will be rejected due to is_color_valid() check
	*/
    col /= dot(col, 1);

	// transform to I1,I2,I3 color space
	col = mul(rgb_2_iii_matrix,col);

	// return chromaticity axes, ignore intensity
	return col.gb;
}

bool is_color_valid(float3 col) {

	// subtract achromatic portion
	col -= min(
		col.r,
		min(
			col.g,
			col.b
		)
	);

	return dot(col, 1) > valid_threshold;
}

[numthreads(16,16,1)]
void ShowResult (uint3 id : SV_DispatchThreadID)
{
	float4 color = float4(0,0,0,1);
	for (uint i = 0; i < num_clusters; i++){
		if (
			tex_arr_clusters_r[uint3(id.xy, i)].a == 1
		) {
			color.rg = cbuf_cluster_centers[i].rg;
			
			/*
				convert from I1,I2,I3 chromaticity to RGB
				assume maximum intensity
			*/
			color.rgb = mul(
				iii_2_rgb_matrix,
				float3(0.3333, color.rg)
			);
		}
	}

	if (!is_color_valid(tex_input[id.xy].rgb)){
		color.rgb /= 16.0;
	}

	tex_output[id.xy] = color;
}

[numthreads(16,16,1)]
void SubSample (uint3 id : SV_DispatchThreadID)
{
    if (downscale == false){
        tex_output[id.xy] = tex_input[
            id.xy * sub_sample_multiplier + sub_sample_offset
        ];
    } else {
        tex_output[id.xy] = tex_input.SampleLevel(
            sampler_tex_input,
            float2(
                (id.xy + 0.5) / texture_size
            ),
            subsample_mip_level
        );
    }
}

[numthreads(16,16,1)]
void AttributeClusters (uint3 id : SV_DispatchThreadID)
{
	float min_dist = 1000;
	// 2 coordinates within [-0.5; 0.5] range
	// theoretical maximum distance is sqrt(2)
	
	uint clusterID = -1;

	float3 col = tex_input[id.xy].rgb;
    float2 projCol = project(col);

	bool valid = is_color_valid(col);

	float dist_list[max_num_clusters];

	for (uint i = 0; i < num_clusters; i++) {
		float dist = length(
			cbuf_cluster_centers[i].rg -
			projCol
		);

		dist_list[i] = dist;

		if (dist < min_dist) {
			clusterID = i;
			min_dist = dist;
		}
	}

	for (uint k = 0; k < num_clusters; k++) {
		float4 result = 0;

		if (
			!KHM ||
			is_near_zero(min_dist) // prevent division by zero in KHM
		){
			// K-Means weights
			result.w = (k == clusterID);
		} else {
			/*
				K-Harmonic means weights

				q_{i,k}
				(Equation 7.6)

				Zhang, Bin. "Generalized k-harmonic means--boosting in unsupervised learning." HP LABORATORIES TECHNICAL REPORT HPL 137 (2000).
			*/
			
			float top = pow(abs(min_dist), p-2);
			float bottom = 1.0;

			if (k != clusterID) {
				top *= pow(
					abs(min_dist / dist_list[k]), 
					p+2
				);
			}

			for (uint n = 0; n < num_clusters; n++){
				if (n == clusterID) {
					continue;
				}
				
				bottom += pow(
					abs(min_dist / dist_list[n]),
					p
				);
			}

			result.w = top / (bottom * bottom);
        }

		if (!valid) {
			result.xyw = 0;
		} else {
			result.xy = projCol * result.w;
		}

		switch(k) {
			case 0:
				result.z = valid ? (min_dist * min_dist) : 0;
				break;
			case 1:
				result.z = valid;
				break;
			default:
				result.z = 0;
				break;
		}

		tex_arr_clusters_rw[uint3(id.xy, k)] = result;
	}
}

[numthreads(1,1,1)]
void RandomSwap (uint3 id : SV_DispatchThreadID)
{
    float3 sampleCol = tex_input[
        cbuf_random_positions[random_cluster_center].xy
    ].rgb;

    if (
        // prevents bugs!
		!is_color_valid(sampleCol)
    ) {
        return;
    }

	cbuf_cluster_centers[random_cluster_center].xy = project(sampleCol);
}

[numthreads(1,1,1)]
void ValidateCandidates (uint3 id : SV_DispatchThreadID)
{
	/*
			|0              |numClusters	|
			|---------------|---------------|
			|  new centers	| old centers	|
	*/
	float oldVariance = cbuf_cluster_centers[num_clusters].z;
	float newVariance = cbuf_cluster_centers[0].z;

	if (
		is_variance_valid(newVariance) && (
			!is_variance_valid(oldVariance) ||
			newVariance < oldVariance
		)
	){
		// variance improved

		// save new centers as old
		for (uint i = 0; i < num_clusters; i++) {
			cbuf_cluster_centers[i + num_clusters] = cbuf_cluster_centers[i];
		}
	} else {
		// variance did not improve

		// restore old centers as new
		for (uint i = 0; i < num_clusters; i++) {
			cbuf_cluster_centers[i] = cbuf_cluster_centers[i + num_clusters];
		}
	}
}

// how to store the previous overall Variance to compare to candidate overall Variance?
// store it in cluster center compute buffer (a copy in every entry)

[numthreads(32,1,1)]
void UpdateClusterCenters (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= num_clusters) {
		return;
	}

	float4 aggregatedColor = tex_arr_clusters_r.SampleLevel(
		sampler_tex_arr_clusters_r,
		float3(0.5, 0.5, id.x),
		mip_level
	);

	float4 clusterCenter = 0;

	if (id.x == 0){
		// compute variance

		float aggregatedVariance = aggregatedColor.z;

		float aggregatedvalid = tex_arr_clusters_r.SampleLevel(
			sampler_tex_arr_clusters_r,
			float3(0.5, 0.5, 1),
			mip_level
		).z;

		// clusterCenter.z = variance
		if (!is_near_zero(aggregatedvalid)){
			clusterCenter.z = aggregatedVariance / aggregatedvalid;
		} else {
			clusterCenter.z = -1;
		}
	}

	// clusterCenter.w = not empty (flag)
	clusterCenter.w = 0;

	// clusterCenter.xy = cluster center
	if (!is_near_zero(aggregatedColor.w)) {
		// cluster is not empty

		// clusterCenter.w = not empty (flag)
		clusterCenter.w = 1;

		clusterCenter.xy = aggregatedColor.xy / aggregatedColor.w;
	} else {
		// cluster is empty

		if (do_random_sample_empty_clusters) {
			// randomize empty cluster

			clusterCenter.xy = project(
				tex_input[
					cbuf_random_positions[id.x].xy
				].rgb
			);
		} else {
			// keep previous cluster center
			
			clusterCenter.xy = cbuf_cluster_centers[id.x].xy;
		}
	}

	cbuf_cluster_centers[id.x] = clusterCenter;

	if (reject_old) {
		cbuf_cluster_centers[id.x + num_clusters] = clusterCenter;
	}
}