// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ShowResult
#pragma kernel AttributeClusters
#pragma kernel UpdateClusterCenters
#pragma kernel RandomSwap
#pragma kernel ValidateCandidates
#pragma kernel SubSample
#pragma kernel GenerateVariance
#pragma kernel GatherVariance

#define threshold 0.1
#define max_num_clusters 16
#define invalid_variance 100 // impossibly large distance to indicate empty cluster

bool final;
bool reject_old;
bool show_reference;
bool store_variance;
bool do_random_sample_empty_clusters;
bool KHM;

uint randomClusterCenter;
uint mip_level;
uint ref_mip_level;
uint texture_size;

uint num_clusters;

uint sub_sample_multiplier;
uint2 sub_sample_offset;
bool downscale;

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> tex_input;
SamplerState sampler_tex_input;

RWTexture2D<float4> tex_output;

RWTexture2DArray<float4> tex_arr_clusters_rw;
Texture2DArray<float4> tex_arr_clusters_r;
SamplerState sampler_tex_arr_clusters_r;

RWTexture2D<float2> tex_variance_rw;
Texture2D<float2> tex_variance_r;
SamplerState sampler_tex_variance_r;

RWStructuredBuffer<float4> cbuf_cluster_centers;
RWStructuredBuffer<int4> cbuf_random_positions;

inline float pow2(float x){
	return x*x;
}

inline float pow3(float x){
	return x*x*x;
}

inline float pow4(float x){
	return pow2(
		pow2(x)
	);
}

inline float pow5(float x){
	return pow4(x)*x;
}

float2 project(float3 col)
{
	col -= min(
		col.r,
		min(
			col.g,
			col.b
		)
	);
	col /= dot(1, col);
	return col.rg;
}

float test(float3 col) {
	float3 sf = col - min(
		col.r,
		min(
			col.g,
			col.b
		)
	);

	return dot(sf, 1);
}

float3 RGBtoHSV(float3 RGB)
{
    float3 HSV = 0;
    float M = min(RGB.r, min(RGB.g, RGB.b));
    HSV.z = max(RGB.r, max(RGB.g, RGB.b));
    float C = HSV.z - M;
    if (C != 0)
    {
        HSV.y = C / HSV.z;
        float3 D = (((HSV.z - RGB) / 6) + (C / 2)) / C;
        if (RGB.r == HSV.z)
            HSV.x = D.b - D.g;
        else if (RGB.g == HSV.z)
            HSV.x = (1.0/3.0) + D.r - D.b;
        else if (RGB.b == HSV.z)
            HSV.x = (2.0/3.0) + D.g - D.r;
        if ( HSV.x < 0.0 ) { HSV.x += 1.0; }
        if ( HSV.x > 1.0 ) { HSV.x -= 1.0; }
    }
    return HSV;
}

float3 HUEtoRGB(in float H)
{
	float R = abs(H * 6 - 3) - 1;
	float G = 2 - abs(H * 6 - 2);
	float B = 2 - abs(H * 6 - 4);
	return saturate(float3(R,G,B));
}

float3 HSVtoRGB(in float3 HSV)
{
	float3 RGB = HUEtoRGB(HSV.x);
	return ((RGB - 1) * HSV.y + 1) * HSV.z;
}

[numthreads(4,4,1)]
void ShowResult (uint3 id : SV_DispatchThreadID)
{
	float4 color = float4(0,0,0,1);
	for (uint i = 0; i < num_clusters; i++){
		if (
			tex_arr_clusters_r[uint3(id.xy, i)].a == 1
		) {
			color.rg = cbuf_cluster_centers[i].rg;
			color.b = 1.0 - color.r - color.g;
		}
	}

	if (show_reference) {
		color.rg = project(tex_input[id.xy].rgb);
	}

	if (test(tex_input[id.xy].rgb) <= threshold){
		color.rgb /= 128.0;
	}

	uint borderWidth = texture_size / 32;

	if (show_reference) {
		if (
			id.x < borderWidth ||
			id.x > texture_size - borderWidth ||
			id.y < borderWidth ||
			id.y > texture_size - borderWidth
		) {
			color.rgb = float3(1,0,0);
		}
	}

	tex_output[id.xy] = color;
}

[numthreads(4,4,1)]
void SubSample (uint3 id : SV_DispatchThreadID)
{
    if (downscale == false){
        tex_output[id.xy] = tex_input[
            id.xy * sub_sample_multiplier + sub_sample_offset
        ];
    } else {
        tex_output[id.xy] = tex_input.SampleLevel(
            sampler_tex_input,
            float2(
                (id.xy + 0.5) / texture_size
            ),
            ref_mip_level
        );
    }
}

[numthreads(4,4,1)]
void AttributeClusters (uint3 id : SV_DispatchThreadID)
{
	float min_dist = invalid_variance;
	// difference calculated on 2 coordinates within [0,1] range
	// theoretical maximum distance is sqrt(2)
	
	uint clusterID;

	float3 col = tex_input[id.xy].rgb;
	bool included = test(col) > threshold;

	float dist_list[max_num_clusters];

	for (uint i = 0; i < num_clusters; i++) {
		float dist = length(
			cbuf_cluster_centers[i].rg -
			project(col)
		);

		dist_list[i] = dist;

		if (dist < min_dist) {
			clusterID = i;
			min_dist = dist;
		}
	}

	for (uint k = 0; k < num_clusters; k++) {
		float4 result;

		if (!KHM || final){
			result.w = (k == clusterID);
		} else {
            float top = min_dist;

            if (k != clusterID) {
                top *= pow5(
                    min_dist / dist_list[k]
                );
            }

            float bottom = 1.0;

            for (uint n = 0; n < num_clusters; n++){
                if (n == clusterID) {
                    continue;
                }
                
                bottom += pow3(min_dist / dist_list[n]);
            }

            result.w = top / pow2(bottom);
        }

        result.xy = project(col) * result.w;
        // used for Variance monitoring
        // all random swap attempts are done on the same input frame
        // bias from included flag remains constant and does not affect choice
        result.z = pow2(min_dist);

		if (!included && !final) {
			result = 0;
		}

		tex_arr_clusters_rw[uint3(id.xy, k)] = result;
	}
}

[numthreads(1,1,1)]
void RandomSwap (uint3 id : SV_DispatchThreadID)
{
    float3 sampleCol = tex_input[
        cbuf_random_positions[randomClusterCenter].xy
    ].rgb;

    if (
        // prevents actual bugs!
        test(sampleCol) <= threshold
    ) {
        return;
    }

	cbuf_cluster_centers[randomClusterCenter].xy = project(sampleCol);
}


[numthreads(32,1,1)]
void ValidateCandidates (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= num_clusters) {
		return;
	}

	float4 old = cbuf_cluster_centers[id.x + num_clusters];
	float4 candidate = cbuf_cluster_centers[id.x];

	// z is same on all cluster centers
	// and contains Variance across ALL clusters

	if (candidate.z < old.z) {
		cbuf_cluster_centers[id.x + num_clusters] = candidate;
	} else {
		cbuf_cluster_centers[id.x] = old;
	}
}

// how to store the previous overall Variance to compare to candidate overall Variance?
// store it in cluster center compute buffer (a copy in every entry)

[numthreads(32,1,1)]
void UpdateClusterCenters (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= num_clusters) {
		return;
	}

    float4 aggregatedColor = tex_arr_clusters_r.SampleLevel(
		sampler_tex_arr_clusters_r,
		float3(0.5, 0.5, id.x),
		mip_level
	);

	float4 clusterCenter = 0;

	if (aggregatedColor.w != 0) {
		clusterCenter.xy = aggregatedColor.xy / aggregatedColor.w;
        clusterCenter.z = aggregatedColor.z;
	} else {
		if (do_random_sample_empty_clusters) {
			clusterCenter.xy = project(
				tex_input[
					cbuf_random_positions[id.x].xy
				].rgb
			);
		} else {
			clusterCenter.xy = cbuf_cluster_centers[id.x].xy;
		}
        clusterCenter.z = invalid_variance;
	}

	cbuf_cluster_centers[id.x] = clusterCenter;
	if (reject_old) {
		cbuf_cluster_centers[id.x + num_clusters] = clusterCenter;
	}
}

[numthreads(4,4,1)]
void GenerateVariance (uint3 id : SV_DispatchThreadID)
{	
	float3 col = tex_input[id.xy].rgb;

	bool included = test(col) > threshold;
	
	float min_dist = invalid_variance;
	// difference calculated on 2 coordinates within [0,1] range
	// theoretical maximum distance is sqrt(2)

	for (uint i = 0; i < num_clusters; i++) {
		float dist = length(
			cbuf_cluster_centers[i].rg -
			project(col)
		);

		if (dist < min_dist) {
			min_dist = dist;
		}
	}

	tex_variance_rw[id.xy].rg = float2(
		included ? pow2(min_dist) : 0,
		included
	);
}

[numthreads(32,1,1)]
void GatherVariance (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= num_clusters) {
		return;
	}

	float2 variance_sample = tex_variance_r.SampleLevel(
		sampler_tex_variance_r,
		float2(0.5, 0.5),
		ref_mip_level
	);

	float4 clusterCenter = cbuf_cluster_centers[id.x];
	clusterCenter.w = variance_sample.r / variance_sample.g;

	cbuf_cluster_centers[id.x] = clusterCenter;
}