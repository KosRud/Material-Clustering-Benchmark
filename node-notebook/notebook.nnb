{
    "cells": [
        {
            "language": "javascript",
            "source": [
                "const { Plotly, display } = require('node-kernel');\r\nconst merge = require('deepmerge');\r\nconst assert = require(\"assert/strict\");\r\n\r\nconst normalSizeLayout = {\r\n    width: 600,\r\n    height: 400,\r\n    font: {\r\n        size: 15,\r\n    },\r\n    margin: {\r\n        l: 80,\r\n        r: 4,\r\n        b: 40,\r\n        t: 50, // for title\r\n    },\r\n    yaxis: {\r\n        title: {\r\n            standoff: 4,\r\n        },\r\n        automargin: true,\r\n    },\r\n    xaxis: {\r\n        automargin: true,\r\n    }\r\n}\r\n\r\nconst doubleSizeLayout = merge(normalSizeLayout, {\r\n    width: 2400,\r\n    height: 1600,\r\n    font: {\r\n        size: 60,\r\n    },\r\n    margin: {\r\n        l: 320,\r\n        r: 200,\r\n        b: 200,\r\n        t: 200, // for title\r\n    },\r\n});\r\n\r\nconst sharedLayout = normalSizeLayout;\r\nconst lineWidth = [4,16][0];"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "# Loading report collections"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "import fs from \"fs\";\r\nimport unpackUnityJson from \"./lib/unpackUnityJson\";\r\nimport loadReportCollection from \"./lib/loadReportCollection\";\r\nimport path from \"path\";\r\n\r\nconst JSONStream = require(\"JSONStream\");\r\n\r\nconst reportCollections = await (async function () {\r\n    const reportDir = \"./reports/\";\r\n    const reportCollections = {};\r\n    for (const reportFileName of fs.readdirSync(reportDir)) {\r\n        const reportPath = path.join(reportDir, reportFileName);\r\n\r\n        let reportName = reportFileName;\r\n        const reportNameParts = reportFileName.split(\".\");\r\n        reportNameParts.splice(-1, 1);\r\n        reportName = reportNameParts.join(\"\");\r\n\r\n        console.log(\"start\");\r\n\r\n        reportCollections[reportName] = loadReportCollection(\r\n            unpackUnityJson(\r\n                await (async function () {\r\n                    const jsonObj = {};\r\n\r\n                    return new Promise((resolve) => {\r\n                        const stream = fs\r\n                            .createReadStream(reportPath, { encoding: \"utf8\" })\r\n                            .pipe(JSONStream.parse(\"$*\"));\r\n\r\n                        stream.on(\"data\", (data) => {\r\n                            jsonObj[data.key] = data.value;\r\n                            console.log(\r\n                                `data entries: ${\r\n                                    Object.keys(data.value).length\r\n                                }, key: ${data.key}`\r\n                            );\r\n\r\n                            if (data.key == \"references\") {\r\n                                resolve(jsonObj);\r\n                            }\r\n                        });\r\n                    });\r\n                })()\r\n            )\r\n        );\r\n\r\n        console.log(\"end\");\r\n    }\r\n\r\n    return new Promise((resolve) => resolve(reportCollections));\r\n})();\r\n\r\nconsole.log(reportCollections);\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Report format"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "{\r\n    const reportNames = Object.keys(reportCollections);\r\n    console.dir({\r\n        'report names': reportNames,\r\n        'report format': Object.values(reportCollections)[0][0],\r\n    });\r\n}"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "# Plots\r\n\r\n## Empty Cluster Randomization"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const merge = require('deepmerge');\r\n\r\n{\r\n    const reports = reportCollections['Empty cluster randomization'];\r\n\r\n    const videoNameOptions = Array.from(\r\n        new Set(reports.map((report) => report.launchParameters.videoName))\r\n    ).sort();\r\n\r\n    for (const aggregatedStatName of ['rmse', 'peakRmse']) {\r\n        for (const videoName of videoNameOptions) {\r\n            const subsetVideo = reports.filter(\r\n                (report) => report.launchParameters.videoName == videoName\r\n            );\r\n\r\n            const data = [true, false].map((doRandomizeEmptyClusters) => {\r\n                const subsetJitterSize = subsetVideo.filter(\r\n                    (report) =>\r\n                        report.launchParameters.doRandomizeEmptyClusters ==\r\n                        doRandomizeEmptyClusters\r\n                );\r\n\r\n                return {\r\n                    y: subsetJitterSize.map(\r\n                        (report) =>\r\n                            report.measurement.aggregated[aggregatedStatName]\r\n                    ),\r\n\r\n                    x: subsetJitterSize.map(\r\n                        (report) =>\r\n                            `${report.launchParameters.workingTextureSize}`\r\n                    ),\r\n\r\n                    name: `${\r\n                        doRandomizeEmptyClusters ? 'randomized' : 'unchanged'\r\n                    }`,\r\n                    type: 'bar',\r\n                };\r\n            });\r\n\r\n            // todo fix definitions Plotly.Layout\r\n            const layout = merge(sharedLayout, {\r\n                xaxis: {\r\n                    title: 'working texture size',\r\n                    type: 'category',\r\n                },\r\n\r\n                yaxis: {\r\n                    title: {\r\n                        text: `${aggregatedStatName} RMSE`,\r\n                    },\r\n                },\r\n\r\n                legend: {\r\n                    title: {\r\n                        text: 'empty clusters',\r\n                    },\r\n                },\r\n\r\n                title: `Empty cluster randomization (video ${videoName})`,\r\n            });\r\n\r\n            Plotly.newPlot('', data, layout);\r\n            display.html('<br>');\r\n        }\r\n    }\r\n}\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Subsampling"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const merge = require(\"deepmerge\");\r\n\r\n{\r\n    const reports = reportCollections[\"Subsampling\"];\r\n\r\n    const textureSizeOptions = Array.from(\r\n        new Set(\r\n            reports.map((report) => report.launchParameters.workingTextureSize)\r\n        )\r\n    );\r\n\r\n    const videoNameOptions = Array.from(\r\n        new Set(reports.map((report) => report.launchParameters.videoName))\r\n    ).sort();\r\n\r\n    for (const aggregatedStatName of [\"rmse\", /*\"peakRmse\"*/]) {\r\n        for (const videoName of videoNameOptions) {\r\n            const subsetVideo = reports.filter(\r\n                (report) => report.launchParameters.videoName == videoName\r\n            );\r\n\r\n            const data = textureSizeOptions.map((textureSize) => {\r\n                const subsetTextureSize = subsetVideo\r\n                    .filter(\r\n                        (report) =>\r\n                            report.launchParameters.workingTextureSize ==\r\n                            textureSize\r\n                    )\r\n                    .reverse();\r\n\r\n                return {\r\n                    y: subsetTextureSize.map(\r\n                        (report) =>\r\n                            report.measurement.aggregated[aggregatedStatName]\r\n                    ),\r\n\r\n                    x: subsetTextureSize.map(\r\n                        (report) => `${report.launchParameters.numClusters}`\r\n                    ),\r\n\r\n                    name: `${textureSize}`,\r\n                    type: \"bar\",\r\n                };\r\n            });\r\n\r\n            // todo fix definitions Plotly.Layout\r\n            const layout = merge(sharedLayout, {\r\n                xaxis: {\r\n                    title: \"number of clusters\",\r\n                    type: \"category\",\r\n                },\r\n\r\n                yaxis: {\r\n                    title: {\r\n                        text: (() => {\r\n                            switch (aggregatedStatName) {\r\n\t\t\t\t\t\t\t\tcase \"rmse\":\r\n\t\t\t\t\t\t\t\t\treturn \"RMSE\";\r\n\t\t\t\t\t\t\t\tcase \"peakRmse\":\r\n\t\t\t\t\t\t\t\t\treturn \"peak RMSE\";\r\n\t\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t\treturn \"error\";\r\n                            }\r\n                        })(),\r\n                    },\r\n                },\r\n\r\n                legend: {\r\n                    title: {\r\n                        text: \"texture size\",\r\n                    },\r\n                },\r\n\r\n                title: `Subsampling (video ${videoName})`,\r\n            });\r\n\r\n            Plotly.newPlot(\"\", data, layout);\r\n            display.html(\"<br>\");\r\n        }\r\n    }\r\n}\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Subsample vs Downscale"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const merge = require('deepmerge');\r\n\r\n{\r\n    const reports = reportCollections['Scaling vs subsampling'];\r\n\r\n    const doDownscaleOptions = Array.from(\r\n        new Set(reports.map((report) => report.launchParameters.doDownscale))\r\n    );\r\n\r\n    const videoNameOptions = Array.from(\r\n        new Set(reports.map((report) => report.launchParameters.videoName))\r\n    ).sort();\r\n\r\n    for (const aggregatedStatName of ['rmse', 'peakRmse']) {\r\n        for (const videoName of videoNameOptions) {\r\n            const subsetVideo = reports.filter(\r\n                (report) => report.launchParameters.videoName == videoName\r\n            );\r\n\r\n            const data = doDownscaleOptions.map((doDownscale) => {\r\n                const subsetDoDownscale = subsetVideo.filter(\r\n                    (report) =>\r\n                        report.launchParameters.doDownscale == doDownscale\r\n                );\r\n\r\n                return {\r\n                    y: subsetDoDownscale.map(\r\n                        (report) =>\r\n                            report.measurement.aggregated[aggregatedStatName]\r\n                    ),\r\n\r\n                    x: subsetDoDownscale.map(\r\n                        (report) =>\r\n                            `${report.launchParameters.workingTextureSize}`\r\n                    ),\r\n\r\n                    name: `${doDownscale ? 'downscale' : 'subsample'}`,\r\n                    type: 'bar',\r\n                };\r\n            });\r\n\r\n            // todo fix definitions Plotly.Layout\r\n            const layout = merge(sharedLayout, {\r\n                xaxis: {\r\n                    title: 'working texture size',\r\n                    type: 'category',\r\n                },\r\n\r\n                yaxis: {\r\n                    title: {\r\n                        text: `${aggregatedStatName} RMSE`,\r\n                    },\r\n                },\r\n\r\n                title: `Downscaling vs subsampling (video ${videoName})`,\r\n            });\r\n\r\n            Plotly.newPlot('', data, layout);\r\n            display.html('<br>');\r\n        }\r\n    }\r\n}\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Jitter\r\n\r\n### Scanline jitter"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const merge = require(\"deepmerge\");\r\n\r\n{\r\n    const reports = reportCollections[\"Scanline jitter\"];\r\n\r\n    const jitterSizeOptions = Array.from(\r\n        new Set(\r\n            reports.map((report) =>\r\n                Number.parseInt(report.launchParameters.jitterSize)\r\n            )\r\n        )\r\n    );\r\n    jitterSizeOptions.sort((a, b) => a - b);\r\n\r\n    const videoNameOptions = Array.from(\r\n        new Set(reports.map((report) => report.launchParameters.videoName))\r\n    ).sort();\r\n\r\n    for (const aggregatedStatName of [\"rmse\" /*'peakRmse'*/]) {\r\n        for (const videoName of videoNameOptions) {\r\n            const subsetVideo = reports.filter(\r\n                (report) => report.launchParameters.videoName == videoName\r\n            );\r\n\r\n            const data = jitterSizeOptions.map((jitterSize) => {\r\n                const subsetJitterSize = subsetVideo.filter(\r\n                    (report) => report.launchParameters.jitterSize == jitterSize\r\n                );\r\n\r\n                return {\r\n                    y: subsetJitterSize.map(\r\n                        (report) =>\r\n                            report.measurement.aggregated[aggregatedStatName]\r\n                    ),\r\n\r\n                    x: subsetJitterSize.map(\r\n                        (report) =>\r\n                            `${report.launchParameters.workingTextureSize}`\r\n                    ),\r\n\r\n                    name: `${jitterSize}`,\r\n                    type: \"bar\",\r\n                };\r\n            });\r\n\r\n            // todo fix definitions Plotly.Layout\r\n            const layout = merge(sharedLayout, {\r\n                xaxis: {\r\n                    title: \"working texture size\",\r\n                    type: \"category\",\r\n                },\r\n\r\n                yaxis: {\r\n                    title: {\r\n                        text: (() => {\r\n                            switch (aggregatedStatName) {\r\n                                case \"rmse\":\r\n                                    return \"RMSE\";\r\n                                case \"peakRmse\":\r\n                                    return \"peak RMSE\";\r\n                                default:\r\n                                    return \"error\";\r\n                            }\r\n                        })(),\r\n                    },\r\n                },\r\n\r\n                legend: {\r\n                    title: {\r\n                        text: \"jitter size\",\r\n                    },\r\n                },\r\n\r\n                title: `Scanline jitter (video ${videoName})`,\r\n            });\r\n\r\n            Plotly.newPlot(\"\", data, layout);\r\n            display.html(\"<br>\");\r\n        }\r\n    }\r\n}\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### Staggered jitter"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const merge = require('deepmerge');\r\n\r\n{\r\n    const reports = reportCollections['Staggered jitter'];\r\n\r\n    const jitterSizeOptions = Array.from(\r\n        new Set(\r\n            reports.map((report) =>\r\n                Number.parseInt(report.launchParameters.jitterSize)\r\n            )\r\n        )\r\n    );\r\n    jitterSizeOptions.sort((a, b) => a - b);\r\n\r\n    const videoNameOptions = Array.from(\r\n        new Set(reports.map((report) => report.launchParameters.videoName))\r\n    ).sort();\r\n\r\n    for (const aggregatedStatName of ['rmse', /*'peakRmse'*/]) {\r\n        for (const videoName of videoNameOptions) {\r\n            const subsetVideo = reports.filter(\r\n                (report) => report.launchParameters.videoName == videoName\r\n            );\r\n\r\n            const data = jitterSizeOptions.map((jitterSize) => {\r\n                const subsetJitterSize = subsetVideo.filter(\r\n                    (report) => report.launchParameters.jitterSize == jitterSize\r\n                );\r\n\r\n                return {\r\n                    y: subsetJitterSize.map(\r\n                        (report) =>\r\n                            report.measurement.aggregated[aggregatedStatName]\r\n                    ),\r\n\r\n                    x: subsetJitterSize.map(\r\n                        (report) =>\r\n                            `${report.launchParameters.workingTextureSize}`\r\n                    ),\r\n\r\n                    name: `${jitterSize}`,\r\n                    type: 'bar',\r\n                };\r\n            });\r\n\r\n            // todo fix definitions Plotly.Layout\r\n            const layout = merge(sharedLayout, {\r\n                xaxis: {\r\n                    title: 'working texture size',\r\n                    type: 'category',\r\n                },\r\n\r\n                yaxis: {\r\n                    title: {\r\n                        text: `${aggregatedStatName} RMSE`,\r\n                    },\r\n                },\r\n\r\n                legend: {\r\n                    title: {\r\n                        text: 'jitter size',\r\n                    },\r\n                },\r\n\r\n                title: `Staggered jitter (video ${videoName})`,\r\n            });\r\n\r\n            Plotly.newPlot('', data, layout);\r\n            display.html('<br>');\r\n        }\r\n    }\r\n}\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### Difference"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const merge = require('deepmerge');\r\n\r\n{\r\n    const scanlineJitterReports = reportCollections['Scanline jitter'];\r\n    const staggeredJitterReports = reportCollections['Staggered jitter'];\r\n\r\n    const reportPairs = scanlineJitterReports.map((scanlineJitterReport) => {\r\n        const launchParamsString = JSON.stringify(\r\n            scanlineJitterReport.launchParameters\r\n        );\r\n\r\n        const staggeredJitterReport = staggeredJitterReports.find(\r\n            (report) =>\r\n                JSON.stringify(report.launchParameters) == launchParamsString\r\n        );\r\n\r\n        return {\r\n            scanlineJitterReport: scanlineJitterReport,\r\n            staggeredJitterReport: staggeredJitterReport,\r\n            launchParameters: scanlineJitterReport.launchParameters,\r\n        };\r\n    });\r\n\r\n    const jitterSizeOptions = Array.from(\r\n        new Set(\r\n            scanlineJitterReports.map((report) =>\r\n                Number.parseInt(report.launchParameters.jitterSize)\r\n            )\r\n        )\r\n    );\r\n    jitterSizeOptions.sort((a, b) => a - b);\r\n\r\n    const videoNameOptions = Array.from(\r\n        new Set(\r\n            scanlineJitterReports.map(\r\n                (report) => report.launchParameters.videoName\r\n            )\r\n        )\r\n    ).sort();\r\n\r\n    for (const aggregatedStatName of ['rmse', /*'peakRmse'*/]) {\r\n        for (const videoName of videoNameOptions) {\r\n            const subsetVideo = reportPairs.filter(\r\n                (reportPair) =>\r\n                    reportPair.launchParameters.videoName == videoName\r\n            );\r\n\r\n            const data = jitterSizeOptions.map((jitterSize) => {\r\n                const subsetJitterSize = subsetVideo.filter(\r\n                    (reportPair) =>\r\n                        reportPair.launchParameters.jitterSize == jitterSize\r\n                );\r\n\r\n                return {\r\n                    y: subsetJitterSize.map(\r\n                        (reportPair) =>\r\n                            reportPair.scanlineJitterReport.measurement\r\n                                .aggregated[aggregatedStatName] -\r\n                            reportPair.staggeredJitterReport.measurement\r\n                                .aggregated[aggregatedStatName]\r\n                    ),\r\n\r\n                    x: subsetJitterSize.map(\r\n                        (reportPair) =>\r\n                            `${reportPair.launchParameters.workingTextureSize}`\r\n                    ),\r\n\r\n                    name: `${jitterSize}`,\r\n                    type: 'bar',\r\n                };\r\n            });\r\n\r\n            // todo fix definitions Plotly.Layout\r\n            const layout = merge(sharedLayout, {\r\n                xaxis: {\r\n                    title: 'working texture size',\r\n                    type: 'category',\r\n                },\r\n\r\n                yaxis: {\r\n                    title: {\r\n                        text: `Δ ${aggregatedStatName} RMSE`,\r\n                    },\r\n                },\r\n\r\n                legend: {\r\n                    title: {\r\n                        text: 'jitter size',\r\n                    },\r\n                },\r\n\r\n                title: `Scanline jitter minus staggered jitter (video ${videoName})`,\r\n            });\r\n\r\n            Plotly.newPlot('', data, layout);\r\n            display.html('<br>');\r\n        }\r\n    }\r\n}\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Random Swap - KM iterations"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const merge = require('deepmerge');\r\n\r\n{\r\n    const reports = reportCollections['Random Swap num KMeans'];\r\n\r\n    const numIterationsKmOptions = Array.from(\r\n        new Set(\r\n            reports.map((report) =>\r\n                Number.parseInt(\r\n                    report.launchParameters.dispatcherParameters.numIterationsKm\r\n                )\r\n            )\r\n        )\r\n    );\r\n    numIterationsKmOptions.sort((a, b) => a - b);\r\n\r\n    const videoNameOptions = Array.from(\r\n        new Set(reports.map((report) => report.launchParameters.videoName))\r\n    ).sort();\r\n\r\n    for (const aggregatedStatName of ['rmse', 'peakRmse']) {\r\n        for (const videoName of videoNameOptions) {\r\n            const subsetVideo = reports.filter(\r\n                (report) => report.launchParameters.videoName == videoName\r\n            );\r\n\r\n            const data = numIterationsKmOptions.map((numIterationsKm) => {\r\n                const subsetNumIterationsKm = subsetVideo\r\n                    .filter(\r\n                        (report) =>\r\n                            report.launchParameters.dispatcherParameters\r\n                                .numIterationsKm == numIterationsKm\r\n                    )\r\n                    .sort(\r\n                        (reportA, reportB) =>\r\n                            reportA.launchParameters.numIterations -\r\n                            reportB.launchParameters.numIterations\r\n                    );\r\n\r\n                return {\r\n                    y: subsetNumIterationsKm.map(\r\n                        (report) =>\r\n                            report.measurement.aggregated[aggregatedStatName]\r\n                    ),\r\n\r\n                    x: subsetNumIterationsKm.map(\r\n                        (report) => `${report.launchParameters.numIterations}`\r\n                    ),\r\n\r\n                    name: `${numIterationsKm}`,\r\n                    type: 'scatter',\r\n                    mode: 'lines',\r\n                    line: {\r\n                        width: lineWidth,\r\n                    },\r\n                };\r\n            });\r\n\r\n            // todo fix definitions Plotly.Layout\r\n            const layout = merge(sharedLayout, {\r\n                xaxis: {\r\n                    title: 'total KM iterations',\r\n                    type: 'category',\r\n                },\r\n\r\n                yaxis: {\r\n                    title: {\r\n                        text: `${aggregatedStatName} RMSE`,\r\n                    },\r\n                },\r\n\r\n                legend: {\r\n                    title: {\r\n                        text: 'KM iterations<br>per swap',\r\n                    },\r\n                },\r\n\r\n                title: `Random swap (video ${videoName})`,\r\n            });\r\n\r\n            Plotly.newPlot('', data, layout);\r\n            display.html('<br>');\r\n        }\r\n    }\r\n}\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## KHM parameter p"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "{\r\n    function pToString(p) {\r\n        return (Math.round(p * 100) * 0.01).toFixed(2);\r\n    }\r\n\r\n    const reports = reportCollections[\"KHM parameter p\"];\r\n\r\n    const videoNameOptions = Array.from(\r\n        new Set(reports.map((report) => report.launchParameters.videoName))\r\n    ).sort();\r\n\r\n    const pOptions = Array.from(\r\n        new Set(\r\n            reports.map((report) =>\r\n                pToString(\r\n                    report.launchParameters.abstractDispatcherParameters.p\r\n                )\r\n            )\r\n        )\r\n    ).sort();\r\n\r\n    console.log(pOptions);\r\n\r\n    for (videoName of videoNameOptions) {\r\n        const subsetVideo = reports.filter(\r\n            (report) => report.launchParameters.videoName == videoName\r\n        );\r\n\r\n        const data = [\r\n            {\r\n                y: pOptions.map((p) => {\r\n                    const subsetP = subsetVideo.filter(\r\n                        (report) =>\r\n                            pToString(\r\n                                report.launchParameters\r\n                                    .abstractDispatcherParameters.p\r\n                            ) == p\r\n                    );\r\n                    assert.equal(subsetP.length, 1);\r\n                    return subsetP[0].measurement.aggregated.rmse;\r\n                }),\r\n                x: pOptions,\r\n                type: \"scatter\",\r\n                mode: \"lines\",\r\n                line: {\r\n                    width: lineWidth,\r\n                },\r\n            },\r\n        ];\r\n        /*\r\n\t\t\tconst data = pOptions.map((p) => {\r\n\t\t\t\tconst subsetP = subsetVideo.filter(\r\n\t\t\t\t\t(report) =>\r\n\t\t\t\t\t\tMath.abs(\r\n\t\t\t\t\t\t\treport.launchParameters.abstractDispatcherParameters.p - p\r\n\t\t\t\t\t\t) < 0.00001\r\n\t\t\t\t);\r\n\t\t\t\tassert.equal(subsetP.length, 1);\r\n\r\n\t\t\t\treturn {\r\n\t\t\t\t\ty: subsetP.map((report) => report.measurement.aggregated.rmse),\r\n\t\t\t\t\tx: subsetP.map(\r\n\t\t\t\t\t\t(report) => `${report.launchParameters.numIterations}`\r\n\t\t\t\t\t),\r\n\t\t\t\t\ttype: \"scatter\",\r\n\t\t\t\t\tmode: \"lines\",\r\n\t\t\t\t\tline: {\r\n\t\t\t\t\t\twidth: lineWidth,\r\n\t\t\t\t\t},\r\n\t\t\t\t};\r\n\t\t\t});\r\n\t\t*/\r\n\r\n        const layout = merge(sharedLayout, {\r\n            xaxis: {\r\n                title: \"p\",\r\n            },\r\n            yaxis: {\r\n                title: {\r\n                    text: `RMSE (video ${videoName})`,\r\n                },\r\n            },\r\n            title: `KHM parameter p`,\r\n            showlegend: false,\r\n        });\r\n\r\n        Plotly.newPlot(\"\", data, layout);\r\n    }\r\n}\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Algorithm covnergence"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const { assert } = require(\"console\");\r\nconst merge = require(\"deepmerge\");\r\n\r\n{\r\n    const reports = reportCollections[\"Algorithm convergence\"];\r\n\r\n    const algorithmOptions = Array.from(\r\n        new Set(reports.map((report) => report.launchParameters.algorithm))\r\n    );\r\n    algorithmOptions.sort();\r\n\r\n    const videoNameOptions = Array.from(\r\n        new Set(reports.map((report) => report.launchParameters.videoName))\r\n    ).sort();\r\n\r\n    const subsetStopCondition = reports.filter(\r\n        (report) => report.launchParameters.stopCondition\r\n    );\r\n\r\n    // stop condition box plot\r\n    for (videoName of videoNameOptions) {\r\n        const subsetVideo = subsetStopCondition.filter(\r\n            (report) => report.launchParameters.videoName == videoName\r\n        );\r\n\r\n        const data = algorithmOptions.map((algorithm) => {\r\n            const subsetAlgorithm = subsetVideo.filter(\r\n                (report) => report.launchParameters.algorithm == algorithm\r\n            );\r\n\r\n            assert.equal(subsetAlgorithm.length,1);\r\n\r\n            return {\r\n                y: subsetAlgorithm[0].measurement.rmseByFrame.map(\r\n                    (rmseFrameRecord) => rmseFrameRecord.variance ** 0.5\r\n                ),\r\n                name: (() => {\r\n                    switch (algorithm) {\r\n                        case \"RS (readback)\":\r\n                            return \"RS\";\r\n                        default:\r\n                            return algorithm;\r\n                    }\r\n                })(),\r\n                type: \"box\",\r\n                boxpoints: false,\r\n            };\r\n        });\r\n\r\n        const layout = merge(sharedLayout, {\r\n            xaxis: {\r\n                title: \"algorithm\",\r\n                type: \"category\",\r\n            },\r\n            yaxis: {\r\n                title: {\r\n                    text: `RMSE (video ${videoName})`,\r\n                },\r\n            },\r\n            title: `Stop condition`,\r\n            showlegend: false,\r\n        });\r\n\r\n        Plotly.newPlot(\"\", data, layout);\r\n    }\r\n\r\n    // convergence plots\r\n    for (const aggregatedStatName of ['rmse', 'peakRmse']) {\r\n        const subsetStopCondition = reports.filter(\r\n            (report) => report.launchParameters.stopCondition\r\n        );\r\n\r\n        for (const lineStopCondition of [true, false]) {\r\n            for (const videoName of videoNameOptions) {\r\n                const subsetVideoNoStopCondition = reports\r\n                    .filter(\r\n                        (report) =>\r\n                            report.launchParameters.videoName == videoName\r\n                    )\r\n                    .filter(\r\n                        (report) =>\r\n                            report.launchParameters.stopCondition == false\r\n                    );\r\n\r\n                const data = algorithmOptions.map((algorithm) => {\r\n                    let subsetAlgorithm = subsetVideoNoStopCondition\r\n                        .filter(\r\n                            (report) =>\r\n                                report.launchParameters.algorithm == algorithm\r\n                        )\r\n                        .sort(\r\n                            (reportA, reportB) =>\r\n                                reportA.launchParameters.numIterations -\r\n                                reportB.launchParameters.numIterations\r\n                        );\r\n\r\n                    if (subsetAlgorithm.length == 0) {\r\n                        return {};\r\n                    }\r\n\r\n                    return {\r\n                        y: subsetAlgorithm.map(\r\n                            (report) =>\r\n                                report.measurement.aggregated[\r\n                                    aggregatedStatName\r\n                                ]\r\n                        ),\r\n                        x: subsetAlgorithm.map(\r\n                            (report) =>\r\n                                `${report.launchParameters.numIterations}`\r\n                        ),\r\n                        name: `${algorithm}`,\r\n                        legendgroup: `${algorithm}`,\r\n                        type: \"scatter\",\r\n                        mode: \"lines\",\r\n                        line: {\r\n                            width: lineWidth,\r\n                        },\r\n                    };\r\n                });\r\n\r\n                // lines for stop condition\r\n                if (lineStopCondition) {\r\n                    const numIterationOptions = Array.from(\r\n                        new Set(\r\n                            reports.map(\r\n                                (report) =>\r\n                                    report.launchParameters.numIterations\r\n                            )\r\n                        )\r\n                    );\r\n\r\n                    for (const stopConditionReport of subsetStopCondition.filter(\r\n                        (report) =>\r\n                            report.launchParameters.videoName == videoName\r\n                    )) {\r\n                        data.push({\r\n                            y: numIterationOptions.map(\r\n                                () =>\r\n                                    stopConditionReport.measurement.aggregated[\r\n                                        aggregatedStatName\r\n                                    ]\r\n                            ),\r\n                            x: numIterationOptions,\r\n                            name: (() => {\r\n                                switch (\r\n                                    stopConditionReport.launchParameters\r\n                                        .algorithm\r\n                                ) {\r\n                                    case \"RS (readback)\":\r\n                                        return \"RS (stop)\";\r\n                                    default:\r\n                                        return `${stopConditionReport.launchParameters.algorithm} (stop)`;\r\n                                }\r\n                            })(),\r\n                            legendgroup: (() => {\r\n                                switch (\r\n                                    stopConditionReport.launchParameters\r\n                                        .algorithm\r\n                                ) {\r\n                                    case \"RS (readback)\":\r\n                                        return \"RS\";\r\n                                    default:\r\n                                        return `${stopConditionReport.launchParameters.algorithm}`;\r\n                                }\r\n                            })(),\r\n                            type: \"scatter\",\r\n                            mode: \"lines\",\r\n                            line: {\r\n                                width: lineWidth,\r\n                            },\r\n                        });\r\n                    }\r\n                }\r\n\r\n                // todo fix definitions Plotly.Layout\r\n                const layout = merge(sharedLayout, {\r\n                    xaxis: {\r\n                        title: \"total KM iterations\",\r\n                        type: \"linear\",\r\n                    },\r\n\r\n                    yaxis: {\r\n                        title: {\r\n                            text: (() => {\r\n\t\t\t\t\t\t\t\tswitch(aggregatedStatName) {\r\n\t\t\t\t\t\t\t\t\tcase \"rmse\":\r\n\t\t\t\t\t\t\t\t\t\treturn \"RMSE\";\r\n\t\t\t\t\t\t\t\t\tcase \"peakRmse\":\r\n\t\t\t\t\t\t\t\t\t\treturn \"peak RMSE\";\r\n\t\t\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t\t\treturn \"error\";\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t})(),\r\n                        },\r\n                    },\r\n\r\n                    title: `video ${videoName}`,\r\n                });\r\n\r\n                Plotly.newPlot(\"\", data, layout);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Frame time"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "import merge from 'deepmerge';\r\nimport { report } from 'process';\r\n\r\n{\r\n    const reports =\r\n        /* \r\n        aggregate reports\r\n        minimum frame time from all runs with identical parameter\r\n        */\r\n        (() => {\r\n            const reports = reportCollections['Frame time'];\r\n\r\n            function getReportId(report) {\r\n                const reportId = {\r\n                    algorithm: report.launchParameters.algorithm,\r\n                    videoName: report.launchParameters.videoName,\r\n                    stopCondition: report.launchParameters.stopCondition,\r\n                    workingTextureSize:\r\n                        report.launchParameters.workingTextureSize,\r\n                    readback: report.launchParameters.readback,\r\n                };\r\n                reportId.numIterations = reportId.stopCondition\r\n                    ? undefined\r\n                    : report.launchParameters.numIterations;\r\n\r\n                return JSON.stringify(reportId);\r\n            }\r\n\r\n            const reportIdOptions = Array.from(\r\n                new Set(reports.map((report) => getReportId(report)))\r\n            );\r\n\r\n            return reportIdOptions.map((reportId) => {\r\n                const subset = reports.filter(\r\n                    (report) => getReportId(report) == reportId\r\n                );\r\n\r\n                return subset.reduce((reportA, reportB) => {\r\n                    return merge(reportA, {\r\n                        measurement: {\r\n                            peakFrameTime: Math.min(\r\n                                reportA.measurement.peakFrameTime,\r\n                                reportB.measurement.peakFrameTime\r\n                            ),\r\n                            avgFrameTime: Math.min(\r\n                                reportA.measurement.avgFrameTime,\r\n                                reportB.measurement.avgFrameTime\r\n                            ),\r\n                        },\r\n                    });\r\n                });\r\n            });\r\n        })();\r\n\r\n    const videoNameOptions = Array.from(\r\n        new Set(reports.map((report) => report.launchParameters.videoName))\r\n    ).sort();\r\n\r\n    for (const videoName of videoNameOptions) {\r\n        const subsetVideoName = reports.filter(\r\n            (report) => report.launchParameters.videoName == videoName\r\n        );\r\n\r\n        for (const aggregation of ['rmse', 'peakRmse']) {\r\n            const workingTextureSizeOptions = Array.from(\r\n                new Set(\r\n                    subsetVideoName.map(\r\n                        (report) => report.launchParameters.workingTextureSize\r\n                    )\r\n                )\r\n            );\r\n\r\n            for (const workingTextureSize of workingTextureSizeOptions) {\r\n                const subsetTextureSize = subsetVideoName.filter(\r\n                    (report) =>\r\n                        report.launchParameters.workingTextureSize ==\r\n                        workingTextureSize\r\n                );\r\n\r\n                const algorithmIdOptions = Array.from(\r\n                    new Set(\r\n                        subsetTextureSize.map(\r\n                            (report) => report.launchParameters.algorithm\r\n                        )\r\n                    )\r\n                ).sort();\r\n\r\n                const data = algorithmIdOptions.map((algorithm) => {\r\n                    const subsetAlgorithm = subsetTextureSize.filter(\r\n                        (report) =>\r\n                            report.launchParameters.algorithm == algorithm\r\n                    );\r\n\r\n                    subsetAlgorithm.sort((reportA, reportB) => {\r\n                        if (reportA.launchParameters.stopCondition) {\r\n                            if (reportB.stopCondition) {\r\n                                return 0;\r\n                            }\r\n                            return 1;\r\n                        }\r\n                        if (reportB.launchParameters.stopCondition) {\r\n                            return -1;\r\n                        }\r\n                        return (\r\n                            reportA.launchParameters.numIterations -\r\n                            reportB.launchParameters.numIterations\r\n                        );\r\n                    });\r\n\r\n                    return {\r\n                        x: subsetAlgorithm.map((report) =>\r\n                            report.launchParameters.stopCondition\r\n                                ? 'stop condition'\r\n                                : report.launchParameters.numIterations\r\n                        ),\r\n                        y: subsetAlgorithm.map((report) =>\r\n                            (() => {\r\n                                switch (aggregation) {\r\n                                    case 'mean':\r\n                                        return report.measurement.avgFrameTime;\r\n                                    case 'peak':\r\n                                        return report.measurement.peakFrameTime;\r\n                                    default:\r\n                                        throw 'invalid aggregation';\r\n                                }\r\n                            })()\r\n                        ),\r\n                        type: 'bar',\r\n                        name:\r\n                            `${subsetAlgorithm[0].launchParameters.algorithm}` +\r\n                            (subsetAlgorithm[0].launchParameters\r\n                                .dispatcherParameters.doReadback\r\n                                ? ' (readback)'\r\n                                : ''),\r\n                    };\r\n                });\r\n\r\n                const layout = merge(sharedLayout, {\r\n                    title: {\r\n                        text: `video ${videoName}`,\r\n                    },\r\n                    xaxis: {\r\n                        type: 'category',\r\n                        title: 'number of iterations',\r\n                    },\r\n                    yaxis: {\r\n                        title: `${aggregation} frame time`,\r\n                    },\r\n                });\r\n\r\n                Plotly.newPlot('', data, layout);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
            ],
            "outputs": []
        }
    ]
}