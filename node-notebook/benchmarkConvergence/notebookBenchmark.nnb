{
    "cells": [
        {
            "language": "markdown",
            "source": [
                "# Datasets\n\nhttp://cs.joensuu.fi/sipu/datasets/\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "# Init\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const { Plotly } = require('node-kernel');"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "import fs from 'fs';\n\nfunction loadOrGenerateReport({ loadFromFile, filePath, generationFunc }) {\n    if (loadFromFile) {\n        return JSON.parse(fs.readFileSync(filePath, 'utf-8'));\n    } else {\n        const result = generationFunc();\n        fs.writeFileSync(filePath, JSON.stringify(result, null, 2), {\n            flag: 'w',\n            encoding: 'utf-8',\n        });\n        return result;\n    }\n}\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const merge = require('deepmerge')\n\nconst normalSizeLayout = {\n    width: 600,\n    height: 400,\n    font: {\n        size: 15,\n    },\n    margin: {\n        l: 80,\n        r: 4,\n        b: 40,\n        t: 50, // for title\n    },\n    yaxis: {\n        title: {\n            standoff: 4,\n        },\n        automargin: true,\n    },\n    xaxis: {\n        automargin: true,\n    }\n}\n\nconst doubleSizeLayout = merge(normalSizeLayout, {\n    width: 1200,\n    height: 800,\n    font: {\n        size: 30,\n    },\n    margin: {\n        l: 160,\n        r: 8,\n        b: 80,\n        t: 100, // for title\n    },\n});\n\nconst sharedLayout = doubleSizeLayout;"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "# Benchmark convergence"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "import fs from 'fs';\nimport assert from 'assert/strict';\nimport loadDataset from './loadDataset';\nimport { KMeans, RandomSwap, KHarmonicMeans } from './clustering/clustering';\nimport path from 'path';\nimport copy from 'deepcopy';\n\nconst benchmarkConvergenceResults = loadOrGenerateReport({\n    loadFromFile: false,\n    filePath: './results/convergence.json',\n    generationFunc: () => {\n        const numCenters = 6,\n            maxSamples = 5000,\n            numInits = 40,\n            numRandomSwapRepsPerInit = 40,\n            dimensions = 2,\n            numIterations = 100;\n\n        let results = [];\n\n        const inits =\n            // array of initializations\n            Array(numInits)\n                .fill()\n                .map(() =>\n                    //array of cluster centers\n                    Array(numCenters)\n                        .fill()\n                        .map(() =>\n                            // iterate over coordinates\n                            Array(dimensions)\n                                .fill()\n                                .map(\n                                    // uniform random initialization for each coordinate\n                                    () => Math.random()\n                                )\n                        )\n                );\n\n        const datasetsPath = './datasets/',\n            filePaths = fs\n                .readdirSync(datasetsPath)\n                .map((filePath) => path.join(datasetsPath, filePath));\n\n        const arrLaunchParams = [];\n\n        for (const filePath of filePaths) {\n            const samples = loadDataset({\n                path: filePath,\n                maxSamples: maxSamples,\n            });\n\n            assert.equal(samples[0].length, dimensions);\n\n            for (const initCenters of inits) {\n                arrLaunchParams.push({\n                    samples: samples,\n                    initCenters: initCenters,\n                });\n            }\n        }\n\n        let lastPercent = 0;\n\n        for (const launchId in arrLaunchParams) {\n            const { samples, initCenters } = arrLaunchParams[launchId];\n\n            results = results.concat(\n                new KMeans({\n                    samples: samples,\n                    attribution: samples.map(() => 0),\n                    centers: copy(initCenters),\n                    numIterations: numIterations,\n                }).runClustering()\n            );\n\n            results = results.concat(\n                new KHarmonicMeans({\n                    samples: samples,\n                    attribution: samples.map(() => 0),\n                    centers: copy(initCenters),\n                    numIterations: numIterations,\n                    weights: samples.map(() => initCenters[0].map(() => -1)),\n                }).runClustering()\n            );\n\n            for (const _ of Array(numRandomSwapRepsPerInit)) {\n                results = results.concat(\n                    new RandomSwap({\n                        samples: samples,\n                        attribution: samples.map(() => 0),\n                        centers: copy(initCenters),\n                        numIterations: numIterations,\n                    }).runClustering()\n                );\n            }\n\n            const percentFinished = (launchId / arrLaunchParams.length) * 100;\n            if (percentFinished > lastPercent + 1) {\n                console.log(\n                    `progress: ${percentFinished.toFixed(2).padStart(5)}%    ${\n                        new Date().toString().split(' ')[4]\n                    }`\n                );\n\n                lastPercent = percentFinished;\n            }\n        }\n\n        console.log('');\n        console.log('finished!');\n\n        return results;\n    },\n});\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Report format\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "console.log(JSON.stringify(benchmarkConvergenceResults[0], null, 2));"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Plots"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "import merge from 'deepmerge';\n\n{\n    const algorithmOptions = Array.from(\n        new Set(benchmarkConvergenceResults.map((result) => result.algorithm))\n    );\n\n    // sqrt(variance)\n    {\n        const data = algorithmOptions.map((algorithm) => {\n            const subsetAlgorithm = benchmarkConvergenceResults.filter(\n                (result) => result.algorithm == algorithm\n            );\n\n            const numIterationsOptions = Array.from(\n                new Set(subsetAlgorithm.map((result) => result.numIterations))\n            );\n\n            return {\n                x: numIterationsOptions,\n                y: numIterationsOptions.map((numIterations) => {\n                    const subsetNumItrations = subsetAlgorithm.filter(\n                        (result) => result.numIterations == numIterations\n                    );\n\n                    return (\n                        subsetNumItrations\n                            .map((result) => result.variance ** 0.5)\n                            .reduce((a, b) => a + b) / subsetNumItrations.length\n                    );\n                }),\n                name: algorithm,\n                type: 'scatter',\n                mode: 'lines',\n            };\n        });\n\n        const layout = merge(sharedLayout, {\n            yaxis: {\n                title: `RMSE`,\n            },\n            xaxis: {\n                title: 'number of iterations',\n            },\n            title: {\n                text: `aggregated RMSE`,\n            },\n        });\n\n        Plotly.newPlot('', data, layout);\n    }\n\n    // change of variance\n    {\n        const sharedData = {\n            type: 'scatter',\n            mode: 'lines',\n        };\n\n        const data = merge(\n            sharedData,\n            algorithmOptions.map((algorithm) => {\n                const subsetAlgorithm = benchmarkConvergenceResults.filter(\n                    (result) => result.algorithm == algorithm\n                );\n\n                const numIterationsOptions = Array.from(\n                    new Set(\n                        subsetAlgorithm.map((result) => result.numIterations)\n                    )\n                );\n\n                const variancePerIteration = numIterationsOptions.map(\n                    (numIterations) => {\n                        return {\n                            numIterations: numIterations,\n                            variance: (() => {\n                                const subsetNumIterations =\n                                    subsetAlgorithm.filter(\n                                        (result) =>\n                                            result.numIterations ==\n                                            numIterations\n                                    );\n                                return (\n                                    subsetNumIterations\n                                        .map((result) => result.variance)\n                                        .reduce((a, b) => a + b) /\n                                    subsetNumIterations.length\n                                );\n                            })(),\n                        };\n                    }\n                );\n                for (const index of [...variancePerIteration.keys()].splice(\n                    1\n                )) {\n                    variancePerIteration[index].deltaVariance =\n                        variancePerIteration[index - 1].variance -\n                        variancePerIteration[index].variance;\n                }\n\n                variancePerIteration.shift();\n\n                return {\n                    x: variancePerIteration.map(\n                        (record) => record.numIterations\n                    ),\n                    y: variancePerIteration.map(\n                        (record) => record.deltaVariance\n                    ),\n                    name: algorithm,\n                    type: 'scatter',\n                    mode: 'lines',\n                };\n            })\n        );\n\n        data.push(\n            merge(\n                sharedData,\n                (() => {\n                    const numIterationsOptions = Array.from(\n                        new Set(\n                            benchmarkConvergenceResults\n                                .filter(\n                                    (result) => result.algorithm == 'K-means'\n                                )\n                                .map((result) => result.numIterations)\n                        )\n                    );\n\n                    return {\n                        x: numIterationsOptions,\n                        y: numIterationsOptions.map(() => 1e-4),\n                        name: 'stop condition',\n                    };\n                })()\n            )\n        );\n\n        const layout = merge(sharedLayout, {\n            yaxis: {\n                title: { text: `Δ MSE`, standoff: 20 },\n            },\n            xaxis: {\n                title: 'number of iterations',\n            },\n            title: {\n                text: `MSE change between iterations`,\n            },\n        });\n\n        Plotly.newPlot('', data, layout);\n    }\n}\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "# Benchmark stop condition"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "import fs from 'fs';\nimport assert from 'assert/strict';\nimport loadDataset from './loadDataset';\nimport { KMeans, RandomSwap, KHarmonicMeans } from './clustering/clustering';\nimport path from 'path';\nimport copy from 'deepcopy';\n\nconst benchmarkStopConditionResults = loadOrGenerateReport({\n    loadFromFile: false,\n    filePath: './results/stopCondition.json',\n    generationFunc: () => {\n        const numCenters = 6,\n            maxSamples = 5000,\n            numInits = 40,\n            numRandomSwapRepsPerInit = 40,\n            dimensions = 2,\n            deltaVarianceThreshold = 1e-4;\n\n        let results = [];\n\n        const inits =\n            // array of initializations\n            Array(numInits)\n                .fill()\n                .map(() =>\n                    //array of cluster centers\n                    Array(numCenters)\n                        .fill()\n                        .map(() =>\n                            // iterate over coordinates\n                            Array(dimensions)\n                                .fill()\n                                .map(\n                                    // uniform random initialization for each coordinate\n                                    () => Math.random()\n                                )\n                        )\n                );\n\n        const datasetsPath = './datasets/',\n            filePaths = fs\n                .readdirSync(datasetsPath)\n                .map((filePath) => path.join(datasetsPath, filePath));\n\n        const arrLaunchParams = [];\n\n        for (const filePath of filePaths) {\n            const samples = loadDataset({\n                path: filePath,\n                maxSamples: maxSamples,\n            });\n\n            assert.equal(samples[0].length, dimensions);\n\n            for (const initCenters of inits) {\n                arrLaunchParams.push({\n                    samples: samples,\n                    initCenters: initCenters,\n                });\n            }\n        }\n\n        let lastPercent = 0;\n\n        for (const launchId in arrLaunchParams) {\n            const { samples, initCenters } = arrLaunchParams[launchId];\n\n            const stopCondition = {\n                deltaVariance: deltaVarianceThreshold,\n                failedSwaps: 0,\n            };\n\n            results = results.concat(\n                new KMeans({\n                    samples: samples,\n                    attribution: samples.map(() => 0),\n                    centers: copy(initCenters),\n                    numIterations: stopCondition,\n                }).runClustering()\n            );\n\n            results = results.concat(\n                new KHarmonicMeans({\n                    samples: samples,\n                    attribution: samples.map(() => 0),\n                    centers: copy(initCenters),\n                    numIterations: stopCondition,\n                    weights: samples.map(() => initCenters[0].map(() => -1)),\n                }).runClustering()\n            );\n\n            for (const failedSwaps of [0, 1, 2, 3, 4, 5, 6, 7, 8]) {\n                const stopCondition = {\n                    deltaVariance: deltaVarianceThreshold,\n                    failedSwaps: failedSwaps,\n                };\n\n                for (const _ of Array(numRandomSwapRepsPerInit)) {\n                    results = results.concat(\n                        new RandomSwap({\n                            samples: samples,\n                            attribution: samples.map(() => 0),\n                            centers: copy(initCenters),\n                            numIterations: stopCondition,\n                        }).runClustering()\n                    );\n                }\n            }\n\n            const percentFinished = (launchId / arrLaunchParams.length) * 100;\n            if (percentFinished > lastPercent + 1) {\n                console.log(\n                    `progress: ${percentFinished.toFixed(2).padStart(5)}%    ${\n                        new Date().toString().split(' ')[4]\n                    }`\n                );\n\n                lastPercent = percentFinished;\n            }\n        }\n\n        console.log('');\n        console.log('finished!');\n\n        return results;\n    },\n});\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Report format"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "console.log(\n    JSON.stringify(\n        benchmarkStopConditionResults.find(\n            (report) => report.algorithm == 'Random swap'\n        ),\n        null,\n        2\n    )\n);\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Plots"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const merge = require('deepmerge');\n\n{\n    function getResultId(report) {\n        return JSON.stringify({\n            algorithm: report.algorithm,\n            stopCondition: report.stopCondition,\n        });\n    }\n    const resultIdOptions = Array.from(\n        new Set(\n            benchmarkStopConditionResults.map((result) => getResultId(result))\n        )\n    );\n\n    const aggregatedResults = resultIdOptions\n        .map((resultId) => {\n            const subsetResultId = benchmarkStopConditionResults.filter(\n                (result) => getResultId(result) == resultId\n            );\n\n            function getResultName(result) {\n                let name = result.algorithm;\n\n                if (result.stopCondition != undefined) {\n                    name += ` - ${result.stopCondition.failedSwaps} bad swaps`;\n                }\n\n                return name;\n            }\n\n            return {\n                name: getResultName(subsetResultId[0]),\n                meanRMSE:\n                    subsetResultId\n                        .map((result) => result.variance ** 0.5)\n                        .reduce((rmseA, rmseB) => rmseA + rmseB) /\n                    subsetResultId.length,\n                meanNumIterations:\n                    subsetResultId\n                        .map((result) => result.numIterations)\n                        .reduce(\n                            (numIterationsA, numIterationsB) =>\n                                numIterationsA + numIterationsB\n                        ) / subsetResultId.length,\n            };\n        })\n        .sort((resultA, resultB) => resultA.name > resultB.name);\n\n    // mean RMSE\n    {\n        const data = [\n            {\n                x: aggregatedResults.map((result) => result.name),\n                y: aggregatedResults.map((result) => result.meanRMSE),\n                type: 'bar',\n            },\n        ];\n\n        const layout = merge(sharedLayout, {\n            yaxis: {\n                title: 'mean RMSE',\n            },\n            xaxis: {\n                tickangle: 60,\n            },\n            bargap: 800,\n        });\n\n        Plotly.newPlot('', data, layout);\n    }\n\n    // mean number of iterations\n    {\n        const data = [\n            {\n                x: aggregatedResults.map((result) => result.name),\n                y: aggregatedResults.map((result) => result.meanNumIterations),\n                type: 'bar',\n            },\n        ];\n\n        const layout = merge(sharedLayout, {\n            yaxis: {\n                title: 'mean number of iterations',\n            },\n            xaxis: {\n                tickangle: 60,\n            },\n            bargap: 800,\n        });\n\n        Plotly.newPlot('', data, layout);\n    }\n}\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                ""
            ],
            "outputs": []
        }
    ]
}