{
    "cells": [
        {
            "language": "markdown",
            "source": [
                "http://cs.joensuu.fi/sipu/datasets/"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const { Plotly } = require('node-kernel');"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const sharedLayout = {\n    width: 600,\n    height: 400,\n    font: {\n        size: 15,\n    },\n    margin: {\n        l: 80,\n        r: 4,\n        b: 40,\n        t: 50, // for title\n    },\n};\n\nfunction zip(...rows){\n    if (rows.length == 0){\n        return [];\n    }\n    return [...rows[0].keys()].map(\n        (columnIndex) => rows.map((row) => row[columnIndex])\n    );\n}\n\nfunction transpose (arr) {\n    return [...zip(...arr)];\n}"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "import { kMeans, randomSwap, kHarmonicMeans, getVariance } from './clustering.ts';\nimport fs from 'fs';\nconst merge = require('deepmerge');\nconst copy = require('deepcopy');\n\nconst samples = (() => {\n    let samples = fs\n        .readFileSync('./datasets/S/S1.txt', 'utf-8')\n        // get rows\n        .split('\\n')\n        .map(\n            // split columns by space\n            (line) =>\n                line\n                    .split(' ')\n                    // drop empty columns\n                    .filter((linePart) => linePart != '')\n                    .map(\n                        // convert strings to numbers\n                        (s) => Number.parseFloat(s)\n                    )\n        )\n        .filter(\n            // drop rows with invalid number of columns (e.g. empty)\n            (row) => row.length == 2\n        );\n\n    // normalize\n    samples = transpose(\n        transpose(samples).map((column) => {\n            const min = column.reduce((a, b) => Math.min(a, b));\n            const max = column.reduce((a, b) => Math.max(a, b));\n            const range = max - min;\n            return column.map((x) => (x - min) / range);\n        })\n    );\n\n    return samples;\n})();\n\nconst numCenters = 15;\nconst numInits = 10;\nconst numRepsPerInit = 10;\nconst numIteration = 6;\n\nconst inits =\n    // array of initializations\n    Array(numInits)\n        .fill()\n        .map(() =>\n            //array of cluster centers\n            Array(numCenters)\n                .fill()\n                .map(() =>\n                    // iterate over coordinates\n                    samples[0].map(\n                        // uniform random initialization for each coordinate\n                        () => Math.random()\n                    )\n                )\n        );\n\nconst initCenters = Array(numCenters)\n    .fill()\n    .map(() =>\n        // iterate over coordinates\n        samples[0].map(\n            // uniform random initialization for each coordinate\n            () => Math.random()\n        )\n    );\nconst centers = copy(initCenters);\nconst attribution = Array(samples.length);\nkHarmonicMeans.runClustering({\n    samples,\n    attribution,\n    centers,\n    numIterations: 10,\n});\n\nconst data = [...centers.keys()].map((centerIndex) => {\n    const subset = [...samples.keys()]\n        .filter((sampleIndex) => attribution[sampleIndex] == centerIndex)\n        .map((sampleIndex) => samples[sampleIndex]);\n\n    return {\n        x: subset.map((sample) => sample[0]),\n        y: subset.map((sample) => sample[1]),\n        name: centerIndex,\n        type: 'scatter',\n        mode: 'markers',\n    };\n});\n\nconst layout = merge(sharedLayout, {});\n\nconsole.dir(getVariance(\n    {\n        samples: samples,\n        attribution: attribution,\n        centers: centers\n    }\n));\n\nPlotly.newPlot('', data, layout);\n\n//console.log(JSON.stringify(result.map((r) => r.runResults.Rs.map((r)=>r.quality)), null, 2));\n//console.log(JSON.stringify(result.map((r) => r.runResults.Km.quality), null, 2));\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.error",
                            "value": {
                                "name": "ReferenceError",
                                "message": "transpose is not defined",
                                "stack": "    at <Cell 4> [29, 11]\n    at <Cell 4> [39, 0]\n    at <Cell 4> [64, 46]\n    at Script.runInContext (node:vm:139:12)\n    at Script.runInNewContext (node:vm:144:17)\n    at Object.runInNewContext (node:vm:298:38)\n    at C (/home/madcake/.vscode/extensions/donjayamanne.typescript-notebook-2.0.6/out/extension/server/index.js:2:113345)\n    at t.execCode (/home/madcake/.vscode/extensions/donjayamanne.typescript-notebook-2.0.6/out/extension/server/index.js:2:114312)\n    at k.<anonymous> (/home/madcake/.vscode/extensions/donjayamanne.typescript-notebook-2.0.6/out/extension/server/index.js:2:142156)\n    at k.emit (node:events:527:28)"
                            }
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "# Important\n\nUse standard deviation of sample distance from the nearest cluster as the measure clustering quality - its linear.\n\nAnalyze the means of standard deviation of clustering quality."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                ""
            ],
            "outputs": []
        }
    ]
}