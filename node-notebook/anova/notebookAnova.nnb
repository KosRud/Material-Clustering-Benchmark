{
    "cells": [
        {
            "language": "markdown",
            "source": [
                "http://cs.joensuu.fi/sipu/datasets/"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const { Plotly } = require('node-kernel');"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const sharedLayout = {\n    width: 600,\n    height: 400,\n    font: {\n        size: 15,\n    },\n    margin: {\n        l: 80,\n        r: 4,\n        b: 40,\n        t: 50, // for title\n    },\n};\n\nfunction zip(...rows){\n    if (rows.length == 0){\n        return [];\n    }\n    return [...rows[0].keys()].map(\n        (columnIndex) => rows.map((row) => row[columnIndex])\n    );\n}\n\nfunction transpose (arr) {\n    return [...zip(...arr)];\n}"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "import { Kmeans, RandomSwap, getVariance } from './clustering.ts';\nimport fs from 'fs';\nconst merge = require('deepmerge');\nconst deepcopy = require('deepcopy');\n\nconst samples = (() => {\n    let samples = fs\n        .readFileSync('./datasets/S/S1.txt', 'utf-8')\n        // get rows\n        .split('\\n')\n        .map(\n            // split columns by space\n            (line) =>\n                line\n                    .split(' ')\n                    // drop empty columns\n                    .filter((linePart) => linePart != '')\n                    .map(\n                        // convert strings to numbers\n                        (s) => Number.parseFloat(s)\n                    )\n        )\n        .filter(\n            // drop rows with invalid number of columns (e.g. empty)\n            (row) => row.length == 2\n        );\n\n    // normalize\n    samples = transpose(\n        transpose(samples).map((column) => {\n            const min = column.reduce((a, b) => Math.min(a, b));\n            const max = column.reduce((a, b) => Math.max(a, b));\n            const range = max - min;\n            return column.map((x) => (x - min) / range);\n        })\n    );\n\n    return samples;\n})();\n\nconst numCenters = 20;\nconst numInits = 1;\nconst numRepsPerInit = 6;\nconst numIteration = 40;\n\nconst inits =\n    // array of initializations\n    [...Array(numInits).keys()].map(() =>\n        //array of cluster centers\n        [...Array(numCenters).keys()].map(() =>\n            // iterate over coordinates\n            [...Array(samples[0].length).keys()].map(\n                // uniform random initialization for each coordinate\n                () => Math.random()\n            )\n        )\n    );\n\nconst result = inits.map((initCenters) => {\n    return {\n        initCenters: deepcopy(initCenters),\n        // multiple runs for each initialization\n        runResults: {\n            Rs: [...Array(numRepsPerInit).keys()].map(() => {\n                const centers = deepcopy(initCenters);\n                const attribution = Array(samples.length);\n                RandomSwap.runClustering({\n                    samples,\n                    attribution,\n                    centers,\n                    numIterations: numIteration,\n                });\n                return {\n                    quality: getVariance({\n                        samples,\n                        attribution,\n                        centers,\n                    }),\n                    centers: deepcopy(centers)\n                };\n            }),\n            Km: (() => {\n                const centers = deepcopy(initCenters);\n                const attribution = Array(samples.length);\n                Kmeans.runClustering({\n                    samples,\n                    attribution,\n                    centers,\n                    numIterations: numIteration,\n                });\n                return {\n                    quality: getVariance({\n                        samples,\n                        attribution,\n                        centers,\n                    }),\n                    centers: deepcopy(centers),\n                };\n            })(),\n        },\n    };\n});\n\nconsole.log(JSON.stringify(result.map((r) => r.runResults.Rs.map((r)=>r.quality)), null, 2));\nconsole.log(JSON.stringify(result.map((r) => r.runResults.Km.quality), null, 2));"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "[",
                                "  [",
                                "    0.001836140669517436,",
                                "    0.0018358811735162122,",
                                "    0.0018419432165248217,",
                                "    0.0018249538914150965,",
                                "    0.0018343401580953966,",
                                "    0.0018203783399018954",
                                "  ]",
                                "]",
                                "[",
                                "  0.0018535961414936804",
                                "]",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                ""
            ],
            "outputs": []
        }
    ]
}